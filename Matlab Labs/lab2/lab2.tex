%&LaTeX

\section{Let's Get Digital}

In this lab, you will use Matlab to explore how a physical signal can
be considered to be composed of a sum of sinusoids --- its
\emph{Fourier series}. You will then investigate how capturing this
signal for computer use --- sampling and quantization --- modifies the
signal. Finally, you will see how the choices you make in the
parameters for sampling and quantization affect the quality of the
digitized, computer signal. You will be using the Matlab
\texttt{AnalogSignal} class and functions at
\url{http://faculty.washington.edu/stiber/pubs/Signal-Computing/}.

\subsection{Fourier series representation of a physical signal}

In this section, you will use the Matlab \texttt{AnalogSignal} class
to simulate an analog signal generator. The constructor takes the
following arguments:
\begin{verbatim}
% AnalogSignal(type, amplitude, frequency, dur)
%    Where:
%    type = 'sine', 'cosine', 'square', 'sawtooth', or 'triangle'
%    amplitude = signal amplitude
%    frequency = signal frequency
%    dur = signal duration
\end{verbatim}

Remember that, though an \texttt{AnalogSignal} is simulating an analog
signal, in Matlab all functions are sampled at discrete points in
time. The crufty details of this are hidden away in the class's
implementation.

\paragraph{Step 1.1} Verify that you can get a triangle wave. What is
the code to generate and plot a triangle wave ranging from -1 to 1
Volts with a frequency of 10Hz and a duration of 1sec?

\paragraph{Step 1.2} Recall that any periodic signal can be
represented as a sum of harmonic sinusoids.  The amplitude of each
harmonic is known as the Fourier Series. It may at first seem like
sums of sinusoids would be poor approximations of real periodic
signals, but this is not the case. We can illustrate this using a
triangle wave. The formula for synthesis of a triangle wave with
frequency $\omega_0$ is a sum of harmonically related sine waves (its
Fourier series):
  \[
  x(t) = \sum_{k=0}^{\infty}
  \left( 
    \underbrace{ \frac{8}{\pi^2} \frac{(-1)^k}{(2k+ 1)^2} }_{ \text{amplitude} } 
    \underbrace{ \sin((2k+1)\omega_0 t) }_{ (2k+1)^{th}\text{ harmonic} } 
  \right)
  \]
  In this case, in the analog domain, we are dealing with frequencies
  in Hz, and so $\omega_0 = 2\pi f_0$. Notice that the Fourier Series
  of the triangle wave only uses odd harmonics (i.e., the only
  non-zero frequencies are $(2k+1)\omega_0=\omega_0, 3\omega_0,
  5\omega_0 \cdots$). Also notice that resulting wave will have zero
  mean because there is no ``DC'' term (i.e., $2k+1 \neq 0$ for any
  integer k).

  Write a Matlab script that approximates a triangle wave by summing
  together the first 7 harmonics of its Fourier series; plot the
  resultant signal (i.e., use $f_0$, $2f_0$, $3f_0$, $\cdots 7f_0$,
  where $f_0=$10 Hz). How does this signal compare to the triangle
  wave computed directly in the previous step?



\paragraph{Step 1.3} Another way to view a signal is in the
\emph{frequency domain}. For a signal expressed in terms of its
Fourier series, the frequency representation is merely the
coefficients of the harmonics. Write a Matlab function or script to
compute and plot the spectrum of a triangle wave. You may find the
MATLAB function \texttt{stem} useful.  Note that you are \emph{not}
being asked to plot the triangle wave as a function of time; you
should plot the amplitudes of the component sinusoids as a function of
those sinusoids' frequencies (like the vertical lines in textbook
figure~1.12).  Use your code to plot the spectrum of the triangle wave
from the previous step (first 7 harmonics).

\subsection{Sampling}

The first step in digitization is \emph{sample and hold}, in which the
continuous analog signal is converted to a discrete-time analog signal
(an analog signal that only changes its value at particular points in
time). You will use the \texttt{samplehold} method to do this:
\begin{verbatim}
% samplehold Perform a sample and hold function on an AnalogSignal
% Usage:
%  x = obj.samplehold(h)
% where  obj = AnalogSignal
%        h = hold time in sec (sampling interval)
%        x = resultant sampled AnalogSignal
\end{verbatim}

\paragraph{Step 2.1} Create an analog sine waveform ranging from -5 to
5V with a frequency of 200Hz and a duration of 2 seconds. Produce a
plot with X-axis limits set to make the waveform visible (i.e., don't
just make a 2s plot that tries (and fails) to show 400 cycles of the
sinusoid.

\paragraph{Step 2.2} Use the \texttt{samplehold} method to produce
sampled versions of this signal at 300Hz, 500Hz, 1000Hz, and
2000Hz. Use the Matlab \texttt{subplot} command, and the
\texttt{discreteplot} function provided with this class's Matlab code,
to plot the original and all four sampled signals together. Clearly,
the results are not the same, and none look identical to the original
sine wave. What are the two essential pieces of information about a
sine wave that need to be preserved when sampling it? Does it appear
that all sampled versions are equally useful in achieving this? Why or
why not (in other words, your answer to this question should not be
just ``yes'' or ``no'')?


\subsection{Analog to Digital Conversion}

The last step of digitization is called ``analog to digital
conversion,'' or \emph{quantization}. In this step, the sampled analog
signal is converted to a discrete signal, with values represented by
$b$ bit integers. We will use the \texttt{quant} function provided
with this class's Matlab code to perform this conversion:
\begin{verbatim}
% QUANT Quantize a sampled (discrete) signal using a prescribed
%       number of bits per point.
% Usage:
%  y = quant(x,nb,out)
% where y = digital signal quantized to 2^(nb) bits resolution
%       x = vertical points of sampled signal
%       nb = number of bits to use per point
%      out = 'raw' means output binary values: 0,...,2^(nb-1)
%      otherwise, set ouput value range = input value range
\end{verbatim}

\paragraph{Step 3.1} Write a Matlab function that compares two signals
by computing the \emph{signal to noise ratio} (SNR) that results from
changing one into the other (by quantization). Your function should do
this by first computing \emph{root mean squared} (RMS) error between
the two. In this case, you will be comparing a sampled signal with a
quantized version of it.  To do this, you should subtract the
quantized signal from the sampled signal to produce a vector of
differences (errors), then square each difference value using the
MATLAB \verb|.^| operator (to get squared errors), then take the mean
of these squared values using the MATLAB \verb|mean| function (mean
squared error --- a scalar value), and finally take the square root of
that scalar result (root mean squared error). We can compute the RMS
signal in a similar way, by squaring the signal values, getting the
mean of those squared values, and then taking the square root. The
final result should be a single value --- the signal-to-noise ratio
(SNR) in \emph{decibels}. What is in the numerator and what is in the
denominator of this ratio? Note that this is different than what we
did in the textbook, because we are now doing the computation for a
\emph{specific} signal, not just figuring SNR for a possible
\emph{range} of signal values.



  \paragraph{Step 3.2} Use your code to compute the SNR for a
  quantized sinusoid. Generate an analog signal with with a range of 0
  to 5, frequency of 10Hz, and duration 2sec. Sample it at 25Hz. Use
  2, 4, 8, 12, and 16 bits quantization, and plot SNR on the Y-axis
  versus number of quantization bits on the X-axis.

  \paragraph{Step 3.3} Repeat Step 3.2 using a square waveform with
  the same parameters.

  \paragraph{Step 3.4} Repeat Step 3.2 using a triangle waveform with
  the same parameters.

  \paragraph{Step 3.5} As you double the number of bits used in
  quantization, how does the SNR change? How does this compare to what
  your learned from the textbook? Refer to specific features of your
  plots from Steps~3.2--3.4 to justify your answer.


